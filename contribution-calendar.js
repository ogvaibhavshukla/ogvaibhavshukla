/**
 * üé® Animated GitHub Contribution Calendar - Portable Component
 * A self-contained, animated contribution calendar that can be dropped into any website
 * 
 * Usage:
 * const calendar = new ContributionCalendar({
 *     container: '#my-calendar',
 *     username: 'your-github-username'
 * });
 */

class ContributionCalendar {
    constructor(options = {}) {
        // Default configuration
        const config = window.ContributionCalendarConfig || {};
        
        this.options = {
            container: '#contribution-calendar',
            username: config.GITHUB_USERNAME || 'ogvaibhavshukla',
            theme: config.DEFAULT_THEME || 'dark',
            ...options
        };
        
        // Grid settings
        this.ROWS = config.GRID_ROWS || 7;
        this.COLS = config.GRID_COLS || 53; // Full year + 1 extra week
        this.GAP_PX = config.GAP_SIZE || 3;
        this.SQUARE_PX = config.SQUARE_SIZE || 14;
        this.username = this.options.username;
        
        // Custom date range settings
        this.startDate = config.START_DATE || new Date('2025-01-01'); // January 1st, 2025
        this.endDate = config.END_DATE || new Date('2025-12-31'); // December 31st, 2025
        
        // Pattern types
        this.PATTERNS = {
            GAME_OF_LIFE: 'gameOfLife',
            RIPPLE: 'ripple',
            WAVE: 'wave',
            RAIN: 'rain',
            SPIRAL: 'spiral',
            NOISE: 'noise',
            RULE30: 'rule30'
        };

        // Animation state
        this.grid = this.createEmptyGrid();
        this.isRunning = false;
        this.generation = 0;
        this.currentPattern = this.PATTERNS.GAME_OF_LIFE;
        this.patternState = {};
        this.animationSpeed = config.ANIMATION_SPEED || 150;
        this.maxGenerations = config.MAX_GENERATIONS || 500;
        this.animationFrame = null;
        this.lastUpdateTime = 0;
        this.activeLetterIndex = null;
        this.baselineGrid = null;
        this.githubData = null;

        // Pattern mapping for letters
        this.animateLetterPatterns = [
            this.PATTERNS.GAME_OF_LIFE, // A
            this.PATTERNS.NOISE,        // c
            this.PATTERNS.WAVE,         // t
            this.PATTERNS.SPIRAL,       // i
            this.PATTERNS.RULE30,       // v
            this.PATTERNS.RAIN,         // i
            this.PATTERNS.RIPPLE,       // t
            this.PATTERNS.GAME_OF_LIFE  // y
        ];

        this.init();
    }

    createEmptyGrid() {
        return new Array(this.ROWS).fill(0).map(() => new Array(this.COLS).fill(0));
    }

    createRandomGrid() {
        return new Array(this.ROWS).fill(0).map(() => 
            new Array(this.COLS).fill(0).map(() => Math.random() > 0.7 ? 1 : 0)
        );
    }

    init() {
        this.createContainer();
        this.setupDOM();
        // Set dark mode as default
        this.container.classList.add('dark');
        this.setupEventListeners();
        this.renderGrid();
        this.fetchGithubContributions();
        
        // Initialize with random grid
        this.grid = this.createRandomGrid();
        this.updateGridDisplay();
    }

    createContainer() {
        const targetElement = document.querySelector(this.options.container);
        if (!targetElement) {
            console.error(`Container element "${this.options.container}" not found`);
            return;
        }

        // Create the main container
        this.container = document.createElement('div');
        this.container.className = `contribution-calendar-container ${this.options.theme}`;
        
        // Create the HTML structure
        this.container.innerHTML = `
            <div class="cc-header">
                <h1 class="cc-title" id="cc-title">
                    <span class="cc-letter" data-pattern="gameOfLife" data-index="0">A</span>
                    <span class="cc-letter" data-pattern="noise" data-index="1">c</span>
                    <span class="cc-letter" data-pattern="wave" data-index="2">t</span>
                    <span class="cc-letter" data-pattern="spiral" data-index="3">i</span>
                    <span class="cc-letter" data-pattern="rule30" data-index="4">v</span>
                    <span class="cc-letter" data-pattern="rain" data-index="5">i</span>
                    <span class="cc-letter" data-pattern="ripple" data-index="6">t</span>
                    <span class="cc-letter" data-pattern="gameOfLife" data-index="7">y</span>
                </h1>

            </div>
            
            <div class="cc-calendar-container">
                <div class="cc-grid-container" id="cc-gridContainer">
                    <!-- Grid will be generated by JavaScript -->
                </div>
            </div>
        `;

        targetElement.appendChild(this.container);
    }

    setupDOM() {
        const gridContainer = this.container.querySelector('#cc-gridContainer');
        gridContainer.innerHTML = '';

        for (let col = 0; col < this.COLS; col++) {
            const column = document.createElement('div');
            column.className = 'cc-column';
            column.setAttribute('data-col', col);

            for (let row = 0; row < this.ROWS; row++) {
                const square = document.createElement('div');
                square.className = 'cc-square';
                square.setAttribute('data-row', row);
                square.setAttribute('data-col', col);
                const dateString = this.getDateForGridPosition(row, col);
                square.title = `No contributions on ${dateString}`;
                column.appendChild(square);
            }

            gridContainer.appendChild(column);
        }
    }

    setupEventListeners() {
        // Letter click handlers
        const letters = this.container.querySelectorAll('.cc-letter');
        letters.forEach((letter, index) => {
            letter.addEventListener('click', () => this.handleLetterClick(index));
        });

        // Grid cell click handlers
        const squares = this.container.querySelectorAll('.cc-square');
        squares.forEach(square => {
            square.addEventListener('click', (e) => {
                const row = parseInt(e.target.getAttribute('data-row'));
                const col = parseInt(e.target.getAttribute('data-col'));
                this.toggleCell(row, col);
            });
        });
    }

    handleLetterClick(index) {
        const letters = this.container.querySelectorAll('.cc-letter');
        const newPattern = this.animateLetterPatterns[index];

        if (!this.isRunning) {
            // Start: save baseline and run
            this.baselineGrid = this.grid.map(row => [...row]);
            this.currentPattern = newPattern;
            this.startPatternAnimation();
            this.setActiveLetterIndex(index);
            return;
        }

        if (this.activeLetterIndex === index) {
            // Stop: restore baseline grid (same letter clicked twice)
            this.stopAnimation();
            if (this.baselineGrid) {
                this.grid = this.baselineGrid.map(row => [...row]);
                this.updateGridDisplay();
            }
            this.setActiveLetterIndex(null);
            return;
        }

        // Switch to different pattern
        this.currentPattern = newPattern;
        this.generation = 0;
        this.initializePattern();
        this.setActiveLetterIndex(index);
    }

    setActiveLetterIndex(index) {
        const letters = this.container.querySelectorAll('.cc-letter');
        letters.forEach(letter => letter.classList.remove('active'));
        
        if (index !== null) {
            letters[index].classList.add('active');
        }
        
        this.activeLetterIndex = index;
    }

    toggleCell(row, col) {
        if (row >= 0 && row < this.ROWS && col >= 0 && col < this.COLS) {
            this.grid[row][col] = this.grid[row][col] === 0 ? 1 : 0;
            this.updateGridDisplay();
        }
    }

    renderGrid() {
        this.updateGridDisplay();
    }

    updateGridDisplay() {
        for (let row = 0; row < this.ROWS; row++) {
            for (let col = 0; col < this.COLS; col++) {
                const square = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (square) {
                    const value = this.grid[row][col];
                    const dateString = this.getDateForGridPosition(row, col);
                    
                    // Remove existing classes
                    square.classList.remove('alive-1', 'alive-2', 'alive-3', 'alive-4', 'birth', 'death');
                    
                    if (value > 0) {
                        // Determine contribution level based on value
                        let level = 1;
                        if (value > 10) level = 4;
                        else if (value > 5) level = 3;
                        else if (value > 2) level = 2;
                        
                        square.classList.add(`alive-${level}`);
                        const contributionText = value === 1 ? 'contribution' : 'contributions';
                        square.title = `${value} ${contributionText} on ${dateString}`;
                    } else {
                        square.title = `No contributions on ${dateString}`;
                    }
                }
            }
        }
    }

    getDateForGridPosition(row, col) {
        // Calculate date based on custom date range
        const targetDate = this.calculateDateFromGridPosition(row, col);
        
        // Format as "Month Day" (e.g., "November 16th")
        const months = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        
        const month = months[targetDate.getMonth()];
        const day = targetDate.getDate();
        const dayWithSuffix = this.addOrdinalSuffix(day);
        
        return `${month} ${dayWithSuffix}`;
    }

    calculateDateFromGridPosition(row, col) {
        // Calculate the date based on our custom date range
        // Start from the beginning of the start date's week (Sunday)
        const startWeekBegin = new Date(this.startDate);
        const daysFromSunday = this.startDate.getDay();
        startWeekBegin.setDate(this.startDate.getDate() - daysFromSunday);
        
        // Calculate the target date
        // Each column represents a week, each row a day of the week (0=Sunday, 6=Saturday)
        const targetDate = new Date(startWeekBegin);
        targetDate.setDate(startWeekBegin.getDate() + (col * 7) + row);
        
        return targetDate;
    }

    addOrdinalSuffix(day) {
        if (day >= 11 && day <= 13) {
            return day + 'th';
        }
        switch (day % 10) {
            case 1: return day + 'st';
            case 2: return day + 'nd';
            case 3: return day + 'rd';
            default: return day + 'th';
        }
    }

    addManualContributions() {
        // Manually add specific contributions that are missing
        const manualContributions = [
            { date: '2025-03-10', count: 1 },
            { date: '2025-03-14', count: 1 },
            { date: '2025-04-12', count: 2 },
            { date: '2025-05-12', count: 7 }
        ];

        manualContributions.forEach(contrib => {
            const gridPosition = this.findGridPositionForDate(contrib.date);
            if (gridPosition) {
                this.grid[gridPosition.row][gridPosition.col] = contrib.count;
                console.log(`‚úÖ Added manual contribution: ${contrib.date} = ${contrib.count} contributions at [${gridPosition.row}][${gridPosition.col}]`);
            } else {
                console.log(`‚ùå Could not find grid position for date: ${contrib.date}`);
            }
        });
    }

    findGridPositionForDate(targetDate) {
        // Find the grid position for a specific date using our custom date range
        const target = new Date(targetDate);
        
        // Check if the date is within our custom range
        if (target < this.startDate || target > this.endDate) {
            return null;
        }
        
        // Calculate the position based on our custom date range
        const startWeekBegin = new Date(this.startDate);
        const daysFromSunday = this.startDate.getDay();
        startWeekBegin.setDate(this.startDate.getDate() - daysFromSunday);
        
        // Calculate the difference in days
        const daysDiff = Math.floor((target - startWeekBegin) / (1000 * 60 * 60 * 24));
        
        // Calculate row and column
        const col = Math.floor(daysDiff / 7);
        const row = daysDiff % 7;
        
        // Check if the position is within our grid bounds
        if (col >= 0 && col < this.COLS && row >= 0 && row < this.ROWS) {
            return { row, col };
        }
        
        return null;
    }

    // Animation methods (simplified versions)
    startPatternAnimation() {
        this.stopAnimation();
        this.isRunning = true;
        this.generation = 0;
        
        // Reset to baseline (GitHub data or random)
        if (this.githubData) {
            this.grid = this.githubData.map(row => [...row]);
        } else {
            this.grid = this.createRandomGrid();
        }
        
        this.initializePattern();
        this.animate();
    }

    stopAnimation() {
        this.isRunning = false;
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
        
        // Clear active letter
        const letters = this.container.querySelectorAll('.cc-letter');
        letters.forEach(letter => letter.classList.remove('active'));
        this.activeLetterIndex = null;
    }

    animate() {
        if (!this.isRunning) return;
    
        const now = performance.now();
        const elapsed = now - this.lastUpdateTime;
    
        if (elapsed > this.animationSpeed) {
            this.lastUpdateTime = now - (elapsed % this.animationSpeed);
    
            const { newGrid, hasChanged } = this.executePattern(this.grid, this.currentPattern, this.patternState);
    
            if (this.currentPattern === this.PATTERNS.GAME_OF_LIFE && !hasChanged) {
                this.stopAnimation();
                return;
            }
    
            if (this.generation >= this.maxGenerations) {
                this.stopAnimation();
                return;
            }
    
            this.grid = newGrid;
            this.generation++;
            this.updateGridDisplay();
        }
    
        this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    initializePattern() {
    this.patternState = {};
    
    switch (this.currentPattern) {
        case this.PATTERNS.WAVE:
            this.patternState.time = 0;
            break;
        case this.PATTERNS.SPIRAL:
            this.patternState.time = 0;
            break;
        case this.PATTERNS.RIPPLE:
            this.patternState.ripples = [];
            break;
        case this.PATTERNS.RULE30:
            // Initialize with a single cell in the middle
            this.grid = this.createEmptyGrid();
            this.grid[0][Math.floor(this.COLS / 2)] = 1;
            break;
    }
}

    executePattern(currentGrid, pattern, state) {
        switch (pattern) {
            case this.PATTERNS.GAME_OF_LIFE:
                return this.gameOfLifeStep(currentGrid);
            case this.PATTERNS.RIPPLE:
                return this.rippleStep(currentGrid, state);
            case this.PATTERNS.WAVE:
                return this.waveStep(currentGrid, state);
            case this.PATTERNS.RAIN:
                return this.rainStep(currentGrid, state);
            case this.PATTERNS.SPIRAL:
                return this.spiralStep(currentGrid, state);
            case this.PATTERNS.NOISE:
                return this.noiseStep(currentGrid);
            case this.PATTERNS.RULE30:
                return this.rule30Step(currentGrid);
            default:
                return { newGrid: currentGrid, hasChanged: false };
        }
    }
    
    updatePattern() {
        switch (this.currentPattern) {
            case this.PATTERNS.GAME_OF_LIFE:
                this.updateGameOfLife();
                break;
            case this.PATTERNS.WAVE:
                this.updateWave();
                break;
            case this.PATTERNS.SPIRAL:
                this.updateSpiral();
                break;
            case this.PATTERNS.NOISE:
                this.updateNoise();
                break;
            case this.PATTERNS.RAIN:
                this.updateRain();
                break;
            case this.PATTERNS.RIPPLE:
                this.updateRipple();
                break;
            case this.PATTERNS.RULE30:
                this.updateRule30();
                break;
        }
    }

    // Pattern implementations
    // Improved Conway's Game of Life
    gameOfLifeStep(currentGrid) {
        const newGrid = this.createEmptyGrid();
        let hasChanged = false;

        for (let row = 0; row < this.ROWS; row++) {
            for (let col = 0; col < this.COLS; col++) {
                const neighbors = this.countNeighbors(currentGrid, row, col);
                const currentCell = currentGrid[row][col];

                if (currentCell === 1) {
                    newGrid[row][col] = neighbors === 2 || neighbors === 3 ? 1 : 0;
                } else {
                    newGrid[row][col] = neighbors === 3 ? 1 : 0;
                }

                if (newGrid[row][col] !== currentCell) {
                    hasChanged = true;
                }
            }
        }

        return { newGrid, hasChanged };
    }

    // Improved Wave Pattern
    waveStep(currentGrid, state) {
        const newGrid = this.createEmptyGrid();
        const time = state.time || 0;

        for (let row = 0; row < this.ROWS; row++) {
            for (let col = 0; col < this.COLS; col++) {
                const wave1 = Math.sin(col * 0.2 + time * 0.1);
                const wave2 = Math.sin(row * 0.3 + time * 0.15);
                const combined = (wave1 + wave2) / 2;

                newGrid[row][col] = combined > 0.3 ? 1 : 0;
            }
        }

        this.patternState = { time: time + 1 };
        return { newGrid, hasChanged: true };
    }

    // Improved Ripple Effect
    rippleStep(currentGrid, state) {
        const newGrid = this.createEmptyGrid();
        const { ripples = [] } = state;

        // Add new ripple occasionally
        const newRipples = [...ripples];
        if (Math.random() < 0.05) {
            newRipples.push({
                centerRow: Math.floor(Math.random() * this.ROWS),
                centerCol: Math.floor(Math.random() * this.COLS),
                radius: 0,
                maxRadius: Math.random() * 15 + 5
            });
        }

        // Update existing ripples
        for (let i = newRipples.length - 1; i >= 0; i--) {
            const ripple = newRipples[i];
            ripple.radius += 0.5;

            if (ripple.radius > ripple.maxRadius) {
                newRipples.splice(i, 1);
                continue;
            }

            // Draw ripple
            for (let row = 0; row < this.ROWS; row++) {
                for (let col = 0; col < this.COLS; col++) {
                    const distance = Math.sqrt(
                        Math.pow(row - ripple.centerRow, 2) + Math.pow(col - ripple.centerCol, 2)
                    );

                    if (Math.abs(distance - ripple.radius) < 1) {
                        newGrid[row][col] = 1;
                    }
                }
            }
        }

        this.patternState = { ripples: newRipples };
        return { newGrid, hasChanged: true };
    }

    // Improved Rain Effect
    rainStep(currentGrid, state) {
        const newGrid = [...currentGrid.map(row => [...row])];

        // Add new raindrops at top
        for (let col = 0; col < this.COLS; col++) {
            if (Math.random() < 0.05) {
                newGrid[0][col] = 1;
            }
        }

        // Move existing drops down
        for (let row = this.ROWS - 1; row > 0; row--) {
            for (let col = 0; col < this.COLS; col++) {
                if (currentGrid[row - 1][col] === 1) {
                    newGrid[row][col] = 1;
                    newGrid[row - 1][col] = 0;
                }
            }
        }

        // Clear bottom row occasionally
        for (let col = 0; col < this.COLS; col++) {
            if (Math.random() < 0.3) {
                newGrid[this.ROWS - 1][col] = 0;
            }
        }

        return { newGrid, hasChanged: true };
    }

    // Improved Spiral Pattern
    spiralStep(currentGrid, state) {
        const newGrid = this.createEmptyGrid();
        const time = state.time || 0;
        const centerRow = this.ROWS / 2;
        const centerCol = this.COLS / 2;

        for (let row = 0; row < this.ROWS; row++) {
            for (let col = 0; col < this.COLS; col++) {
                const dx = col - centerCol;
                const dy = row - centerRow;
                const angle = Math.atan2(dy, dx);
                const distance = Math.sqrt(dx * dx + dy * dy);

                const spiralValue = Math.sin(angle * 3 + distance * 0.5 - time * 0.2);
                newGrid[row][col] = spiralValue > 0.5 ? 1 : 0;
            }
        }

        this.patternState = { time: time + 1 };
        return { newGrid, hasChanged: true };
    }

    // Improved Random Noise
    noiseStep(currentGrid) {
        const newGrid = this.createEmptyGrid();

        for (let row = 0; row < this.ROWS; row++) {
            for (let col = 0; col < this.COLS; col++) {
                newGrid[row][col] = Math.random() > 0.8 ? 1 : 0;
            }
        }

        return { newGrid, hasChanged: true };
    }

    // Improved Rule 30
    rule30Step(currentGrid) {
        const newGrid = [...currentGrid.map(row => [...row])];

        // Apply Rule 30 to each row
        for (let row = 0; row < this.ROWS - 1; row++) {
            for (let col = 0; col < this.COLS; col++) {
                const left = col > 0 ? currentGrid[row][col - 1] : 0;
                const center = currentGrid[row][col];
                const right = col < this.COLS - 1 ? currentGrid[row][col + 1] : 0;

                // Rule 30: 111->0, 110->0, 101->0, 100->1, 011->1, 010->1, 001->1, 000->0
                const pattern = (left > 0 ? 4 : 0) + (center > 0 ? 2 : 0) + (right > 0 ? 1 : 0);
                const newValue = [0, 1, 1, 1, 1, 0, 0, 0][pattern];

                newGrid[row + 1][col] = newValue;
            }
        }

        return { newGrid, hasChanged: true };
    }

    // Improved neighbor counting
    countNeighbors(grid, row, col) {
        let count = 0;
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        for (const [dr, dc] of directions) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow < this.ROWS && newCol >= 0 && newCol < this.COLS) {
                count += grid[newRow][newCol];
            }
        }
        return count;
    }

    async fetchGithubContributions() {
        const config = window.ContributionCalendarConfig || {};
        const GITHUB_TOKEN = config.GITHUB_TOKEN;
        
        if (!GITHUB_TOKEN || GITHUB_TOKEN === 'YOUR_GITHUB_TOKEN_HERE') {
            console.log('GitHub token not configured. Using random data for demo.');
            return;
        }

        const query = `
            query($login: String!) {
                user(login: $login) {
                    contributionsCollection {
                        contributionCalendar {
                            weeks {
                                contributionDays {
                                    date
                                    contributionCount
                                    contributionLevel
                                }
                            }
                        }
                    }
                }
            }
        `;

        try {
            const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${GITHUB_TOKEN}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query,
                    variables: { login: this.username }
                })
            });

            const data = await response.json();
            
            if (data.errors) {
                console.error('GitHub API errors:', data.errors);
                console.log('Using random data for demo.');
                return;
            }
            
            if (data.data?.user?.contributionsCollection?.contributionCalendar?.weeks) {
                const weeks = data.data.user.contributionsCollection.contributionCalendar.weeks;
                
                // Debug: Check the date range we're getting from GitHub
                console.log(`üìä Total weeks from GitHub: ${weeks.length}`);
                console.log(`üìÖ Custom date range: ${this.startDate.toISOString().split('T')[0]} to ${this.endDate.toISOString().split('T')[0]}`);
                if (weeks.length > 0) {
                    const firstWeek = weeks[0];
                    const lastWeek = weeks[weeks.length - 1];
                    if (firstWeek.contributionDays.length > 0 && lastWeek.contributionDays.length > 0) {
                        console.log(`üìÖ GitHub data range: ${firstWeek.contributionDays[0].date} to ${lastWeek.contributionDays[lastWeek.contributionDays.length - 1].date}`);
                    }
                }
                
                const grid = [];
                
                // Initialize grid
                for (let row = 0; row < 7; row++) {
                    grid[row] = new Array(this.COLS).fill(0);
                }
                
                // Create a map of dates to contributions from GitHub data
                const dateContributionMap = new Map();
                weeks.forEach(week => {
                    week.contributionDays.forEach(day => {
                        dateContributionMap.set(day.date, day.contributionCount);
                        if (day.contributionCount > 0) {
                            console.log(`üìÖ ${day.date}: ${day.contributionCount} contributions`);
                        }
                        // Debug logging for March dates
                        if (day.date.includes('2025-03-10') || day.date.includes('2025-03-14')) {
                            console.log(`üîç GitHub data: ${day.date}: ${day.contributionCount} contributions`);
                        }
                    });
                });
                
                // Fill grid based on our custom date range
                for (let col = 0; col < this.COLS; col++) {
                    for (let row = 0; row < this.ROWS; row++) {
                        const targetDate = this.calculateDateFromGridPosition(row, col);
                        const dateStr = targetDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                        const contributionCount = dateContributionMap.get(dateStr) || 0;
                        
                        grid[row][col] = contributionCount;
                        
                        // Debug logging for March dates
                        if (dateStr.includes('2025-03-10') || dateStr.includes('2025-03-14')) {
                            console.log(`üîç Custom range mapping [${row}][${col}] = ${dateStr}: ${contributionCount} contributions`);
                        }
                    }
                }

                this.githubData = grid;
                this.githubWeeks = weeks; // Store weeks data for tooltip access
                this.grid = grid;
                
                // Manually add specific contributions
                this.addManualContributions();
                
                this.updateGridDisplay();
                
                // Enhanced logging
                const totalContributions = grid.flat().reduce((sum, val) => sum + val, 0);
                console.log(`‚úÖ Loaded GitHub contributions for ${this.username}`);
                console.log(`üìä Total contributions displayed: ${totalContributions}`);
                
                // Show the actual date range being displayed
                const firstDisplayedDate = this.calculateDateFromGridPosition(0, 0);
                const lastDisplayedDate = this.calculateDateFromGridPosition(6, this.COLS - 1);
                console.log(`üìÖ Calendar displays: ${firstDisplayedDate.toISOString().split('T')[0]} to ${lastDisplayedDate.toISOString().split('T')[0]}`);
                
                // Show recent contributions for debugging
                const recentDays = weeks.slice(-4).flatMap(w => w.contributionDays).slice(-14);
                console.log('üìÖ Recent 14 days:', recentDays.map(d => `${d.date}: ${d.contributionCount}`));
            }
        } catch (error) {
            console.error('Error fetching GitHub data:', error);
            console.log('Using random data for demo.');
        }
    }
}

// Auto-initialize if container exists and config is loaded
document.addEventListener('DOMContentLoaded', () => {
    const defaultContainer = document.querySelector('#contribution-calendar');
    if (defaultContainer && window.ContributionCalendarConfig) {
        window.contributionCalendar = new ContributionCalendar();
    }
});
